Turbo Assembler	 Version 4.1	    02/17/25 17:14:45	    Page 1
frame.asm



      1				     ;------------------------------------------------------------------------------
      2				     ;			     Asm Task to Valentine's day
      3				     ;			       (c) 2025	Muratov	Artyom
      4				     ;------------------------------------------------------------------------------
      5	0000			     .model tiny
      6	0000			     .code
      7				     org 100h
      8	0100  E8 006C		     Start:	     call ReadCmdLine		     ; read info about frame
      9										     ; from command line
     10	0103  E8 0035				     call FindPosFrame		     ; di = start of print frame
     11
     12	0106  E8 0123				     call MakeFrame		     ; make frame
     13
     14	0109  E8 0022				     call StrLen		     ; find size of text
     15										     ; cx = size of text
     16	010C  E8 0012				     call FindPosText		     ; find position of	text
     17										     ; di = start of print text
     18	010F  E8 0005				     call MakeText		     ; write text to frame
     19
     20	0112  B8 4C00				     mov  ax, 4c00h		     ; DOS Fn 4ch = exit (al)
     21	0115  CD 21				     int  21h
     22
     23				     ;------------------------------------------------------------------------------
     24				     ; MakeText	     Func to write text	to frame
     25				     ; Entry:	     bx	= ptr to strat of text in command line
     26				     ;		     di	= start	of print text
     27				     ;		     es	= videoseg
     28				     ;		     ah	= color	of text
     29				     ; Exit:	     None
     30				     ; Destroy:	     bx, si, di
     31				     ;------------------------------------------------------------------------------
     32	0117			     MakeText	     proc
     33	0117  8B F3				     mov  si, bx		     ; si = bx
     34	0119  AC				     lodsb			     ; mov al, ds:[si]
     35										     ; inc si
     36	011A  AB		     NewChar:	     stosw			     ; mov es:[di], ax && di +=	2
     37	011B  AC				     lodsb			     ; mov al, ds:[si]
     38										     ; inc si
     39	011C  3C 24				     cmp  al, 24h		     ; if (al != '$') {
     40	011E  75 FA				     jne  NewChar		     ; goto NewChar}
     41
     42	0120  C3				     ret
     43	0121			     MakeText	     endp
     44
     45				     ;------------------------------------------------------------------------------
     46				     ; FindPosText   Func to find position of text in video memory
     47				     ; Entry:	     cx	= len of text
     48				     ; Exit:	     di	= start	of print text
     49				     ; Destroy:	     di
     50				     ;------------------------------------------------------------------------------
     51	0121			     FindPosText     proc
     52	0121  BF 0050				     mov  di, 80		     ; di = 80
     53	0124  2B F9				     sub  di, cx		     ; di = 80 - cx
     54	0126  81 C7 0780			     add  di, 12 * 80 *	2	     ; di to some middle string
     55										     ; di = start of text
     56	012A  83 E7 FE				     and  di, 0FFFEh		     ; make di even
     57	012D  C3				     ret
Turbo Assembler	 Version 4.1	    02/17/25 17:14:45	    Page 2
frame.asm



     58	012E			     FindPosText     endp
     59
     60				     ;------------------------------------------------------------------------------
     61				     ; StrLen	     Func to find len of string	that end '$'
     62				     ; Entry:	     bx	= start	of text
     63				     ; Exit:	     cx	= len of text
     64				     ; Destroy:	     cx, si
     65				     ;------------------------------------------------------------------------------
     66	012E			     StrLen	     proc
     67	012E  50				     push ax			     ; save old	value of ax in stack
     68	012F  8B F3				     mov  si, bx		     ; si = bx
     69	0131  33 C9				     xor  cx, cx		     ; cx = 0
     70
     71	0133  41		     NewSymbol:	     inc  cx			     ; cx++
     72	0134  AC				     lodsb			     ; mov al, ds:[si]
     73										     ; inc si
     74	0135  3C 24				     cmp  al, 24h		     ; if (al != '$') {
     75	0137  75 FA				     jne  NewSymbol		     ; goto NewSymbol}
     76	0139  58				     pop  ax			     ; back ax from stack
     77	013A  C3				     ret
     78	013B			     StrLen	     endp
     79
     80				     ;------------------------------------------------------------------------------
     81				     ; FindPosFrame  Func to find position of frame in video memory
     82				     ; Entry:	     cx	= len	of frame
     83				     ;		     dx	= high	of frame
     84				     ; Exit:	     di	= start	of print frame
     85				     ; Destroy:	     di
     86				     ;------------------------------------------------------------------------------
     87	013B			     FindPosFrame    proc
     88	013B  33 FF				     xor  di, di		     ; di = 0
     89	013D  50				     push ax			     ; save ax in stack
     90
     91	013E  B8 0050				     mov  ax, 80		     ; ax = 80 (ax = len of screen)
     92	0141  2B C1				     sub  ax, cx		     ; ax = 80 - cx
     93	0143  03 F8				     add  di, ax		     ; di = start in string
     94
     95	0145  B8 0019				     mov  ax, 25		     ; ax  = 25	(ax = high of screen)
     96	0148  2B C2				     sub  ax, dx		     ; ax  = 25	- dx
     97	014A  D1 E8				     shr  ax, 1			     ; ax /= 2 | ax = number of
     98										     ; first string in screen)
     99	014C  52				     push dx			     ; save dx in stack
    100	014D  8B D0				     mov  dx, ax		     ; dx  = ax
    101	014F  D1 E2 D1 E2 D1 E2	D1+		     shl  dx, 4			     ; dx *= 16
    102	      E2
    103	0157  D1 E0 D1 E0 D1 E0	D1+		     shl  ax, 6			     ; ax *= 64
    104	      E0 D1 E0 D1 E0
    105	0163  03 C2				     add  ax, dx		     ; (result:	ax  = 80 * ax)
    106	0165  D1 E0				     shl  ax, 1			     ; ax *= 2
    107										     ; (ax = ptr of first string
    108										     ; in screen)
    109	0167  5A				     pop  dx			     ; back dx from stack
    110	0168  03 F8				     add  di, ax		     ; di = ptr	of upper left cornel
    111										     ; of frame
    112	016A  83 E7 FE				     and  di, 0FFFEh		     ; make di even
    113	016D  58				     pop  ax			     ; back ax from stack
    114	016E  C3				     ret
Turbo Assembler	 Version 4.1	    02/17/25 17:14:45	    Page 3
frame.asm



    115	016F			     FindPosFrame    endp
    116
    117				     ;------------------------------------------------------------------------------
    118				     ; ReadCmdLine   Func to read info about frame parametres
    119				     ; Entry:	     None
    120				     ; Exit:	     si	= ptr	of array of symbols
    121				     ;		     ah	= color	of frame
    122				     ;		     cx	= len	of frame
    123				     ;		     dx	= high	of frame
    124				     ;		     bx	= love letter
    125				     ; Destroy:	     si, ah, cx, dx, bx
    126				     ;------------------------------------------------------------------------------
    127	016F			     ReadCmdLine     proc
    128	016F  BB 0081				     mov  bx, 81h		     ; bx = start of command line
    129	0172  E8 00AA				     call SkipSpaces		     ; skip all	spaces before arg
    130										     ; with len	of frame
    131	0175  E8 0084				     call Atoi			     ; read info about len of frame
    132										     ; and convert it to number
    133										     ; in register cx
    134	0178  E8 00A4				     call SkipSpaces		     ; skip all	spaces before arg
    135										     ; with high of frame
    136	017B  51				     push cx			     ; save len	 of frame
    137										     ; (cx) in stack
    138	017C  E8 007D				     call Atoi			     ; read info about high of frame
    139										     ; and convert it to number
    140										     ; in register cx
    141	017F  8B D1				     mov  dx, cx		     ; dx      = high of frame
    142	0181  59				     pop  cx			     ; back cx = len  of frame
    143	0182  E8 009A				     call SkipSpaces		     ; skip all	spaces before arg
    144										     ; with color of frame
    145	0185  E8 004B				     call Atoih			     ; read info about color
    146										     ; of frame	from cmd line and
    147										     ; record it to byte ah
    148	0188  E8 0094				     call SkipSpaces		     ; skip all	spaces before arg
    149										     ; with mode of frame
    150	018B  E8 0004				     call ModeFrame		     ; read mode from [bx] &&
    151										     ; si = ptr	to array of symbols
    152										     ; to make frame
    153	018E  E8 008E				     call SkipSpaces		     ; skip all	spaces before array
    154										     ; with text about love
    155										     ; bx = start of text
    156	0191  C3				     ret
    157	0192			     ReadCmdLine     endp
    158
    159				     ;------------------------------------------------------------------------------
    160				     ; ModeFrame     Func to find mode of frame	in cmd line
    161				     ; Entry:	     bx	= ptr mode in command line
    162				     ; Exit:	     si	= start	of array with symbols for frame
    163				     ;		     bx	= end of mode
    164				     ; Destroy:	     bx, si, ax
    165				     ;------------------------------------------------------------------------------
    166	0192			     ModeFrame	     proc
    167	0192  8B F3				     mov  si, bx		     ; si = ptr	to number of mode
    168	0194  50				     push ax			     ; save ax in stack
    169
    170	0195  33 C0				     xor  ax, ax		     ; ax = 0
    171	0197  AC				     lodsb			     ; mov al, ds:[si] && inc si
Turbo Assembler	 Version 4.1	    02/17/25 17:14:45	    Page 4
frame.asm



    172	0198  2C 30				     sub  al, 30h		     ; al -= 30h, to get a number
    173										     ; from hex	of char
    174	019A  3C 00				     cmp  al, 0			     ; if (al == 0) {
    175	019C  74 1A				     je	  Custom		     ; goto Custom }
    176										     ;Style + 9	* (frame_style - 1)
    177	019E  BE 026Cr				     lea  si, Style		     ; si = start of 2D	array Style
    178
    179	01A1  53				     push bx			     ; save bx in stack
    180	01A2  8B D8				     mov  bx, ax		     ; bx = ax
    181	01A4  D1 E0 D1 E0 D1 E0			     shl  ax, 3			     ; ax *= 2^3 (ax *=	8)
    182	01AA  03 C3				     add  ax, bx		     ; ax += bx
    183	01AC  2D 0009				     sub  ax, 9			     ; (result ax = 9 *	(ax - 1))
    184
    185	01AF  03 F0				     add  si, ax		     ; si += ax
    186
    187	01B1  5B				     pop  bx			     ; back bx from stack
    188	01B2  83 C3 01				     add  bx, 1			     ; bx = next symbol
    189										     ; after number of mode
    190	01B5  EB 0C 90				     jmp  EndFindMode		     ; goto EndFindMode
    191
    192	01B8  83 C3 01		     Custom:	     add  bx, 1			     ; bx = ptr	symbol after mode
    193	01BB  E8 0061				     call SkipSpaces		     ; bx = start of symbols
    194										     ; for array in cmd	line
    195	01BE  8B F3				     mov  si, bx		     ; si = bx
    196	01C0  E8 0002				     call SkipText		     ; bx = ptr	next symbol after
    197										     ; array of	frame's	symbols
    198	01C3  58		     EndFindMode:    pop  ax			     ; back ax from stack
    199	01C4  C3				     ret
    200	01C5			     Modeframe	     endp
    201
    202				     ;------------------------------------------------------------------------------
    203				     ; SkipText	     func to skip text
    204				     ; Entry:	     bx	= ptr to start of text for skipping
    205				     ; Exit:	     bx	= ptr to symbol	after skipping text
    206				     ; Destroy:	     bx
    207				     ;------------------------------------------------------------------------------
    208	01C5			     SkipText	     proc
    209	01C5  53		     StartTextSkip:  push bx			     ; save value bx in	stack
    210										     ; bx = ptr	to command line
    211	01C6  8A 1F				     mov  byte ptr bl, [bx]	     ; bl = [bx]
    212	01C8  80 FB 24				     cmp  bl, 24h		     ; [bl] = '$'?
    213	01CB  5B				     pop  bx			     ; back bx
    214	01CC  74 03				     je	  EndTextSkip		     ; if ([bl]	== '$')goto EndSkip:
    215
    216	01CE  43				     inc  bx			     ; bx++;
    217	01CF  EB F4				     jmp  StartTextSkip		     ; goto StartSkip:}
    218
    219	01D1  43		     EndTextSkip:    inc  bx			     ; bx++, bx	= symbol after '$'
    220	01D2  C3				     ret
    221	01D3			     SkipText	     endp
    222
    223				     ;------------------------------------------------------------------------------
    224				     ; Atoih	     Func to read command line and make	number hex from	string
    225				     ;		     to	register ah
    226				     ; Entry:	     bx	= start	a number in command line
    227				     ; Exit:	     ah	= hex number from cmd line
    228				     ;		     bx	= ptr to next symbol after number in command line
Turbo Assembler	 Version 4.1	    02/17/25 17:14:45	    Page 5
frame.asm



    229				     ; Destroy:	     bx, ax, si
    230				     ;------------------------------------------------------------------------------
    231	01D3			     Atoih	     proc
    232	01D3  51				     push cx			     ; save cx in stack
    233	01D4  B9 0000				     mov  cx, 0			     ; cx = 0
    234	01D7  8B F3				     mov  si, bx		     ; si = start of number
    235										     ; in cmd line
    236	01D9  33 C0		     NewHexDigit:    xor  ax, ax		     ; mov ax, 0
    237	01DB  AC				     lodsb			     ; mov al, ds:[si] && inc si
    238
    239	01DC  2D 0060				     sub  ax, 60h		     ; if (ax >	60h){
    240	01DF  77 03				     ja	  HexDigit		     ; goto HexDigit } <---(ax > 9)
    241	01E1  05 0030				     add  ax, 30h		     ; else { ax += 30h}
    242	01E4			     HexDigit:					     ; ax = last digit of number
    243	01E4  D1 E1 D1 E1 D1 E1	D1+		     shl  cx, 4			     ; cx *= 2^4 (cx *=	16)
    244	      E1
    245	01EC  03 C8				     add  cx, ax		     ; cx += ax
    246	01EE  80 3C 68				     cmp  byte ptr ds:[si], 68h	     ; if (si == 'h'){
    247	01F1  75 E6				     jne  NewHexDigit		     ; goto NewHexDigit: of number }
    248
    249	01F3  46				     inc  si			     ; si++, to	skip 'h'
    250	01F4  33 C0				     xor  ax, ax		     ; clean ax	(ax = 0)
    251	01F6  8A E1				     mov  ah, cl		     ; ah = color of frame from	cl
    252	01F8  8B DE				     mov  bx, si		     ; bx = ptr	of next	symbol
    253										     ; after number in cmd line
    254	01FA  59				     pop  cx			     ; cx = old	value cx from stack
    255
    256	01FB  C3				     ret
    257	01FC			     Atoih	     endp
    258
    259				     ;------------------------------------------------------------------------------
    260				     ; Atoi	     Func to read command line and make	number from string
    261				     ;		     to	register cx
    262				     ; Entry:	     bx	= start	a number in command line
    263				     ; Exit:	     cx	= number from cmd line
    264				     ;		     bx	= ptr to next symbol after number in command line
    265				     ; Destroy:	     bx, cx, si
    266				     ;------------------------------------------------------------------------------
    267	01FC			     Atoi	     proc
    268	01FC  B9 0000				     mov  cx, 0			     ; cx = 0
    269	01FF  8B F3				     mov  si, bx		     ; si = start of number
    270										     ; in cmd line
    271	0201  33 C0		     NewDigit:	     xor  ax, ax		     ; mov ax, 0
    272	0203  AC				     lodsb			     ; mov al, ds:[si] && inc si
    273	0204  2D 0030				     sub  ax, 30h		     ; ax = last digit of number
    274	0207  50				     push ax			     ; save ax
    275	0208  8B C1				     mov  ax, cx		     ; ax = cx
    276	020A  D1 E1 D1 E1 D1 E1			     shl  cx, 3			     ; cx *= 2^3 (cx *=	8)
    277	0210  03 C8				     add  cx, ax		     ;
    278	0212  03 C8				     add  cx, ax		     ; (result:	cx *= 10)
    279	0214  58				     pop ax			     ; back ax from stack
    280										     ; ax = last digit of number
    281	0215  03 C8				     add  cx, ax		     ; cx += ax
    282	0217  80 3C 20				     cmp  byte ptr ds:[si], 20h	     ; if (si != ' ')
    283	021A  75 E5				     jne  NewDigit		     ; goto NewDigit: of number
    284
    285	021C  8B DE				     mov  bx, si		     ; bx = ptr	of next	symbol
Turbo Assembler	 Version 4.1	    02/17/25 17:14:45	    Page 6
frame.asm



    286										     ; after number in cmd line
    287	021E  C3				     ret
    288	021F			     Atoi	     endp
    289
    290				     ;------------------------------------------------------------------------------
    291				     ; SkipSpaces    Func to skip all space symbols before info	about frame
    292				     ; Entry:	     None
    293				     ; Exit:	     bx	= ptr to start info about frame
    294				     ; Destroy:	     bx
    295				     ;------------------------------------------------------------------------------
    296	021F			     SkipSpaces	     proc
    297	021F  53		     StartSkip:	     push bx			     ; save value bx in	stack
    298										     ; bx = ptr	to command line
    299	0220  8A 1F				     mov  byte ptr bl, [bx]	     ; bl = [bx]
    300	0222  80 FB 20				     cmp  bl, 20h		     ; if ([bx]	!= ' '){
    301	0225  5B				     pop  bx			     ; back bx
    302	0226  75 03				     jne  EndSkip		     ; goto EndSkip:}
    303	0228  43				     inc  bx			     ; else { bx++;
    304	0229  EB F4				     jmp  StartSkip		     ; goto StartSkip:}
    305
    306	022B  C3		     EndSkip:	     ret
    307	022C			     SkipSpaces	     endp
    308
    309				     ;------------------------------------------------------------------------------
    310				     ; MakeFrame     Func to make frame
    311				     ; Entry:	     ah	    - color of frame
    312				     ;		     si	    - ptr   of array of	the symbols for	frame
    313				     ;		     cx	    - len   of frame
    314				     ;		     dx	    - high  of frame
    315				     ;		     di	    - start of print (upper left cornel)
    316				     ; Exit:	     None
    317				     ; Destroy:	     ax, si, cx, dx, di, es
    318				     ;------------------------------------------------------------------------------
    319	022C			     MakeFrame	     proc
    320	022C  57				     push di			     ; save start of print in stack
    321	022D  E8 0036				     call SetEsVideoSeg		     ; di = 0b800h; es = di
    322	0230  5F				     pop  di			     ; back start of print
    323
    324	0231  51				     push cx			     ; save cx in stack
    325	0232  E8 0020				     call MakeStrFrame		     ; make first string of frame
    326	0235  59				     pop  cx			     ; pop cx from stack
    327	0236  83 EA 02				     sub  dx, 2			     ; dx -= 2;	dx = number
    328										     ; of middle strings
    329	0239  81 C7 00A0	     MakeMiddle:     add  di, 80 * 2		     ; di to next string
    330	023D  51				     push cx			     ; save cx
    331	023E  56				     push si			     ; save si
    332	023F  E8 0013				     call MakeStrFrame		     ; make middle string
    333	0242  5E				     pop si			     ; si = &(start symbol of
    334										     ; middle strings)
    335	0243  59				     pop  cx			     ; cx = len	of frame
    336	0244  4A				     dec  dx			     ; dx--;
    337	0245  83 FA 00				     cmp  dx, 0			     ; dx = 0?
    338	0248  75 EF				     jne  MakeMiddle		     ; loop
    339
    340	024A  83 C6 03				     add  si, 3			     ; si = &(start symbol of
    341										     ; end string)
    342	024D  81 C7 00A0			     add  di, 80 * 2		     ; di to next string
Turbo Assembler	 Version 4.1	    02/17/25 17:14:45	    Page 7
frame.asm



    343
    344	0251  E8 0001				     call MakeStrFrame		     ; make end	string of frame
    345
    346	0254  C3				     ret
    347	0255			     MakeFrame	     endp
    348
    349				     ;------------------------------------------------------------------------------
    350				     ; MakeStrFrame  Func to make string of frame
    351				     ; Entry:	     ah	    - color of string
    352				     ;		     si	    - array of symbol for string
    353				     ;		     cx	    - len of string
    354				     ;		     di	    - start of print string
    355				     ;		     es	    - videoseg
    356				     ; Exit:	     None
    357				     ; Destroy:	     ax, cx, si
    358				     ;------------------------------------------------------------------------------
    359	0255			     MakeStrFrame    proc
    360	0255  57				     push di			     ; save di = start of string
    361
    362	0256  AC				     lodsb			     ; ax = first symbol of string
    363										     ; mov al, ds:[si] && inc si
    364	0257  AB				     stosw			     ; mov es:[di], ax && di +=	2
    365
    366	0258  AC				     lodsb			     ; ax = middle symbol of string
    367										     ; mov al, ds:[si] && inc si
    368	0259  83 E9 02				     sub  cx, 2			     ; cx -= 2;	cx = number
    369										     ; of middle symbols
    370	025C  E8 0004				     call PutString		     ; put all middle symbols
    371	025F  AC				     lodsb			     ; ax = end	symbol of string
    372										     ; mov al, ds:[si] && inc si
    373	0260  AB				     stosw			     ; mov es:[di], ax && di +=	2
    374	0261  5F				     pop  di			     ; back di = start of string
    375
    376	0262  C3				     ret
    377	0263			     MakeStrFrame    endp
    378
    379				     ;------------------------------------------------------------------------------
    380				     ; PutString     Func to put string	to consol
    381				     ; Entry:	     ah/ al - color/ symbol
    382				     ;		     cx	    - size of text
    383				     ;		     di	    - start of print
    384				     ;		     es	    - videoseg
    385				     ; Exit:	     None
    386				     ; Destroy:	     es, cx, di
    387				     ;------------------------------------------------------------------------------
    388	0263			     PutString	     proc
    389	0263  F3> AB				     rep stosw			     ; mov es:[di], ax && di +=	2
    390										     ; cx -= 1;	cx = 0?; make loop
    391	0265  C3				     ret
    392	0266			     PutString	     endp
    393
    394				     ;------------------------------------------------------------------------------
    395				     ; SetEsVideoSeg Func to set ptr of	videoseg to es
    396				     ; Entry:	     None
    397				     ; Exit:	     None
    398				     ; Destroy:	     es, di
    399				     ;------------------------------------------------------------------------------
Turbo Assembler	 Version 4.1	    02/17/25 17:14:45	    Page 8
frame.asm



    400	0266			     SetEsVideoSeg   proc
    401	0266  BF B800				     mov  di, 0b800h		     ; VIDEOSEG
    402	0269  8E C7				     mov  es, di		     ; es = videoseg
    403	026B  C3				     ret
    404	026C			     SetEsVideoSeg   endp
    405
    406				     ;------------------------------------------------------------------------------
    407				     ;		   2D Array of frame's symbols
    408				     ;â„–      1.1   1.2   1.3	 2.1   2.2   2.3   3.1	 3.2   3.3
    409				     ;1--------------------------------------------------------------
    410	026C  C9 CD BB BA 00 BA	C8+  Style db 0c9h, 0cdh, 0bbh,	0bah,  00h, 0bah, 0c8h,	0cdh, 0bch
    411	      CD BC
    412	0275  03 03 03 03 00 03	03+	   db 03h,  03h,  03h,	03h,  00h,  03h,  03h,	03h,  03h
    413	      03 03
    414	027E  DA C4 BF B3 00 B3	C0+	   db 0dah, 0c4h, 0bfh,	0b3h,  00h, 0b3h, 0c0h,	0c4h, 0d9h
    415	      C4 D9
    416	0287  31 32 33 34 35 36	37+	   db "123456789"
    417	      38 39
    418	0290  DC DC DC DD 00 DE	DF+	   db 0dch, 0dch, 0dch,	0ddh,  00h, 0deh, 0dfh,	0dfh, 0dfh
    419	      DF DF
    420	0299  24 24 24 24 00 24	24+	   db 024h, 024h, 024h,	024h,  00h, 024h, 024h,	024h, 024h
    421	      24 24
    422	02A2  E0 E1 E7 E1 E0 E7	E7+	   db 0e0h, 0e1h, 0e7h,	0e1h, 0e0h, 0e7h, 0e7h,	0e1h, 0e0h
    423	      E1 E0
    424	02AB  F4 2B F4 B3 00 B3	F5+	   db 0f4h, 02bh, 0f4h,	0b3h,  00h, 0b3h, 0f5h,	02bh, 0f5h
    425	      2B F5
    426
    427				     ; 1.1 - start  symbol of first  string
    428				     ; 1.2 - middle symbol of first  string
    429				     ; 1.3 - end    symbol of first  string
    430				     ; 2.1 - start  symbol of middle strings
    431				     ; 2.2 - middle symbol of middle strings
    432				     ; 2.3 - end    symbol of middle strings
    433				     ; 3.1 - start  symbol of end    string
    434				     ; 3.2 - middle symbol of end    string
    435				     ; 3.3 - end    symbol of end    string
    436				     ;------------------------------------------------------------------------------
    437
    438				     end	     Start
Turbo Assembler	 Version 4.1	    02/17/25 17:14:45	    Page 9
Symbol Table




Symbol Name			  Type	 Value

??DATE				  Text	 "02/17/25"
??FILENAME			  Text	 "frame	  "
??TIME				  Text	 "17:14:45"
??VERSION			  Number 040A
@32BIT				  Text	 0
@CODE				  Text	 DGROUP
@CODESIZE			  Text	 0
@CPU				  Text	 0101H
@CURSEG				  Text	 _TEXT
@DATA				  Text	 DGROUP
@DATASIZE			  Text	 0
@FILENAME			  Text	 FRAME
@INTERFACE			  Text	 000H
@MODEL				  Text	 1
@STACK				  Text	 DGROUP
@WORDSIZE			  Text	 2
ATOI				  Near	 DGROUP:01FC
ATOIH				  Near	 DGROUP:01D3
CUSTOM				  Near	 DGROUP:01B8
ENDFINDMODE			  Near	 DGROUP:01C3
ENDSKIP				  Near	 DGROUP:022B
ENDTEXTSKIP			  Near	 DGROUP:01D1
FINDPOSFRAME			  Near	 DGROUP:013B
FINDPOSTEXT			  Near	 DGROUP:0121
HEXDIGIT			  Near	 DGROUP:01E4
MAKEFRAME			  Near	 DGROUP:022C
MAKEMIDDLE			  Near	 DGROUP:0239
MAKESTRFRAME			  Near	 DGROUP:0255
MAKETEXT			  Near	 DGROUP:0117
MODEFRAME			  Near	 DGROUP:0192
NEWCHAR				  Near	 DGROUP:011A
NEWDIGIT			  Near	 DGROUP:0201
NEWHEXDIGIT			  Near	 DGROUP:01D9
NEWSYMBOL			  Near	 DGROUP:0133
PUTSTRING			  Near	 DGROUP:0263
READCMDLINE			  Near	 DGROUP:016F
SETESVIDEOSEG			  Near	 DGROUP:0266
SKIPSPACES			  Near	 DGROUP:021F
SKIPTEXT			  Near	 DGROUP:01C5
START				  Near	 DGROUP:0100
STARTSKIP			  Near	 DGROUP:021F
STARTTEXTSKIP			  Near	 DGROUP:01C5
STRLEN				  Near	 DGROUP:012E
STYLE				  Byte	 DGROUP:026C

Groups & Segments		  Bit Size Align  Combine Class

DGROUP				  Group
  _DATA				  16  0000 Word	  Public  DATA
  _TEXT				  16  02B4 Word	  Public  CODE
